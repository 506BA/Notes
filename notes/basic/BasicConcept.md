### BLOCKCHAIN

### 密码学基础

#### 哈希函数

哈希函数（Hash Function）是指能将任意大小的输入（Key）映射到固定大小的哈希值（Hash Value）的函数。Key可以是固定长度如int类型，也可以是任意字符串，甚至可以是经纬度或者高维的向量。

在密码学中，哈希函数的输入key也叫message，输出hash value也叫消息摘要，哈希函数记作h=H(m)。

一个好的哈希函数至少具有两个特性：

- 计算要足够快

- 最小化碰撞（即输出的哈希值尽可能不会重复）



#### 密码哈希函数

密码学中的哈希函数被称为cryptographic hash function，常用的哈希函数包括：SHA-256算法、Keccak算法、SM3算法、MD5算法。比特币中使用的哈希算法为SHA-256(secure hash algorithm)，具有如下性质

- collision resistance（collision free 抗碰撞性）—— 不同的输入很难获得相同的输出，通常用于检验系统数据是否被篡改（任何哈希函数无法被理论证明collision resistance，只能通过实践检验，如MD5已可以人为制造碰撞）。
- hiding —— 通过输出无法倒推输入，输入应该比较大，同时应该分布较为均匀，因此通常会在后面拼接随机数再进行哈希（加盐操作）。同时，与collision resistance一起实现数字委托书digital commitment（digital equivalent of a sealed envelope），也即是零知识证明应用场景。
- puzzle friendly —— 哈希值的计算是不可预测的，只能老实计算，作为工作量证明以及挖矿的基础。同时，实际使用有着difficult to solve but easy to verify的特性。

![](.\images\哈希示例.png)



#### 零知识证明

零知识证明指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。

> 例如预测明天哪只股票可以涨停，但是又不能在明天之前透露具体股票HK00700，因为这个消息会影响到别的交易者的交易决策。
> 这个时候就可以运用到上述哈希算法的性质一和性质二，将HK00700通过SHA-256得出014bd6806fe99bcc36ff53e5faa9353556f7c41bda5b0bfb2b13e46139dfdd3e，这时将这串哈希值公布到网上，并说明这支股票明天会涨停。

首先，根据性质二Hiding，得到这串哈希值无法使得其余的交易者反推出我预测的明日会涨停的股票为HK00700，所以也不会影响其他交易者对于HK00700的交易决策发生改变。其次，当第二天收盘后，只需要证明预测是正确的。这时就需要用到性质一，可以证明输入值（预测值）确实可以得出上述一样的哈希值，因为但凡输入值修改一定，得到的哈希值（输出值）就截然不同，所以无法造假。

零知识证明在区块链中的应用场景是在加密货币中实现隐私交易。在区块链网络中，**用户（证明者）**需要将交易明文广播给所有**矿工（验证者）**，由他们来校验交易的合法性。但是有些情况下，基于隐私的考虑，又不想把交易的具体内容公布出来。



#### 对称加密

最早的加密体系是对称的加密体系（symmetric encryption  algorithm）。如A、B两方进行通信，双方事先商量好一个密钥（encryption  key），发送方使用密钥加密，接收方使用密钥解密。因为加密解密用的是用一个密钥，所以这是对称的加密体系。其优点是加解密速度快。但是这种方式假设了存在某种安全的渠道，能够把密钥分发给通讯双方，这是对称加密体系的一个弱点。

<img src=".\images\对称密钥.png" style="zoom:50%;" />



#### 非对称加密

非对称的加密体系（asymmetric encryption  algorithm）不再像对称加密那样使用一个密钥，而是使用一对密钥，即公钥和私钥。公钥可以公布给所有人，私钥只能自己掌握，加密用的是公钥，解密用的是私钥。

> 例如A要发信息给B，那么A会使用B的公钥对信息进行加密，B收到信息后用B自己的私钥进行解密就能得到原来的信息。

也就是说加密和解密用的都是接收方的公钥和私钥。这样做的好处是公钥是不用保密的，可以告诉所有人。只有私钥是要保密的，但是私钥只需要保存在本地就可以了，不用传递给任何人，这样就避免了传输密钥过程不安全的问题。要回复对方再用对方的公钥加密，始终都不需要知道其他人的私钥，这就解决了对称加密体系中密钥分发不安全（不方便）的问题。但是，生成公私钥需要使用好的随机源，确保不会生成同样的公私钥对。

<img src=".\images\非对称密钥.png" style="zoom: 25%;"/>



#### 数字签名

在本地创建一对公钥和私钥（pubic key, private key）再进行处理后，则完成了区块链账户建立。其中，公钥经过特定操作后即是用户账户编号，私钥即是用户的账户密码。这一对公钥和私钥是用来进行数字签名。用户A发起交易时使用私钥进行数字签名，其他用户可以使用用户A的公钥验证这笔交易。

比特币中使用的签名算法不仅在生成公钥私钥对时有好的随机源，在之后每次签名的时候也要有好的随机源。如果签名时使用的随机源不好，就有可能泄露私钥。比特币系统中的签名，一般是先对message取一个哈希，然后再对哈希值签名。

<img src=".\images\数字签名验证过程.png"/>

上图用户A使用数字签名向用户B传输一份文件的过程：

- 首先，文件经过单向散列函数的处理得到一份占128位的摘要（无论文件多大，经过单向散列函数的处理，生成的摘要都是128位），这份摘要相当于该文件的"指纹"，能够唯一地识别文件。**注意：**只要文件发生改动，经过单向散列函数处理后得到地摘要都会不一样。所以，文件和文件的摘要具有很强的对应关系。
- 随后，用户A使用自己地私钥对这份128位地摘要进行加密，得到一份加密地摘要。
- 然后，用户A把文件、加密的摘要和公钥打包一起发给用户B。传输的过程中并没有对文件进行加密处理。
- 用户B将收到的文件经过单向散列函数处理得出一份128位摘要，这份摘要是通过收到的文件得到的，存在被更改的可能；使用A提供的公钥对收到的"加密的摘要"进行解密得到另一份128位摘要，这份摘要是通过原始文件得到的，一般认为代表真正的文件；然后将两份摘要进行比较。
- 如果两份摘要相等，说明文件经过用户A签名之后，在传输的过程中没有被更改；若不相等，说明文件在传输过程中被更改了，或者说已经不是原来的文件了，此时用户A的签名失效。

数字签名在区块链可以用于验证账户，账户A发起了一笔比特币转账，系统先将该交易进行数字摘要生成，然后用账户A的私钥对摘要进行加密，形成数字签名。完成后，系统将原文（交易信息）与数字签名一起广播给矿工，矿工用账户A的公钥进行验证，如果验证成功，则说明该交易确实是账户A发出的，且信息未被更改。在这个过程中，账户A仅仅需要在转账时输入私钥。



### 数据结构基础

#### 哈希指针

哈希指针既要能够指明结构体的地址，也要保存结构体的哈希值，以便对其践行验证防止篡改。实际应用中，只要是无环的数据结构，都可以考虑使用哈希指针取代普通指针，有环的数据结构可能出现循环依赖的问题。

哈希指针由两部分组成：

- 指向一些信息存储的指针
- 该信息的加密哈希值

指针可用于获取信息，哈希值可用于验证信息未更改。

![](.\images\哈希指针.png)

需要注意的是，存储在哈希指针中的哈希是前一个块的整个数据的哈希，其中还包括指向该块之前的块的哈希指针。这使得在不通知他人的情况下篡改区块链中的区块是不可能的。我们只需要保留指向区块链最后一块的哈希指针即可。当需要验证整个区块链数据是否修改时，我们可以通过向后遍历区块并逐个验证哈希来判断链中的任何区块是否被篡改。

举例说明：

> - 攻击者想要篡改链中的一个区块，比如说区块1。
> - 攻击者由于哈希函数的“无冲突”属性而更改了块1的内容，因此他无法找到与旧哈希具有相同哈希的另一数据。因此，此修改后的块的哈希也已更改。
> - 为了避免其他人注意到不一致，他还需要在下一个块（即块2）中更改该块的哈希指针。
> - 现在，更改了块2的内容，因此要使该故事保持一致，必须更改块3中的哈希指针。
> - 最后，攻击者转到指向区块链最后一块的哈希指针，这对他来说是一个障碍，因为我们保留并记住该哈希指针。

![](.\images\哈希指针攻击.png)



#### 默克尔树

默克尔树（Merkle tree）是带有哈希指针的多叉树结构。默克尔树与普通多叉树的一个重要区别就是用哈希指针代替了普通指针，其最下层叶节点是数据块（data block），每个数据块都是一笔交易（transaction），非叶节点为叶节点的哈希值，最终只需要存储根节点的哈希值（root hash），只要任何一个数据块发生改动，都会传到到根哈希值。因此，根哈希会被保存在区块头部，而默克尔树主体包括数据块都是存在。

默克尔树可以实现Merkle proof，从需要验证的数据块叶节点到根节点的验证路径即被称为Merkle proof，也称为proof of membership，复杂度为log(n)。以下图为例，轻节点需要验证L1中的一笔交易时，只需要等待全节点发送图中Hash 0-1、Hash 1和Top Hash三个哈希值即可验证。

![](.\images\默克尔树.png)

注：如果需要证明默克尔树中不存在某笔交易，暴力遍历需要复杂度为n。考虑排序默克尔树（sorted Merkle tree），即将每个数据块取哈希，根据哈希值进行排序，可以加快搜索，复杂度降为log(n)。比特币中使用的是普通的默克尔树，因为实际中没有这种需求。



#### 区块链结构

区块链是许多区块由哈希指针相连，方向为后一块指向前一块。区块链与普通链表的一个重要区别就是区块链使用的是哈希指针，而不是普通指针。第一个区块被称为genesis block（创世区块），之后的每个区块都包含之前区块的哈希指针，这样做的好处可以防止之前区块被篡改，一旦发生篡改需要篡改后面的所有区块的哈希指针。

根据这个性质，轻节点可以只保存最近的区块，而不用存储所有区块。当需要其他区块时，可以从全节点取到，然后进行哈希即可验证。

![](.\images\区块链结构1.png)



### 区块链基础

#### 名词释义

- 区块链

区块链可以通俗地被理解为一个分布式的公共账本，这个账本由各个区块连成一个链条。在传统记账系统中，记账权掌握在中心服务器手中。而在区块链中，链条上的每一个区块都能在上面记录信息，构成点对点的记账系统。

区块链技术并不是一门全新的学科，而是由多种技术整合的结果，包括密码学、数学、经济学、网络科学等。这些技术以特定方式组合在一起，形成了一种新的去中心化数据记录与存储体系，并给存储数据的区块打上时间戳使其形成一个连续的、前后关联的诚实数据记录存 储结构，最终目的是建立一个保证诚实的数据系统，可将其称为能够保证系统诚实的分布式数据库。

在这个系统中，只有系统本身是值得信任的，所以数据记录、存储与更新规则是为建立人们对区块链系统的信任而设计。系统通过每一个参与者的动作广播给所有参与者保障整个过程的安全、透明，解决了信任问题。也因此，区块链技术被认为是下一代颠覆性的核心技术。 区块链作为构造信任的机制将可能改变整个人类社会价值传递的方式。

![](.\images\区块链示意图.png)

- 比特币：比特币（Bitcoin）是一种加密货币，也是一种分布式数字货币，使用密码学原理进行加密和确认交易。比特币使用密码学技术来确保货币交易的安全性和不可更改性，这意味着比特币交易是不可篡改的。比特币是完全去中心化的，不受任何人控制，可以在互联网上以匿名方式进行交易。
- 以太坊：以太坊（Ethereum）是一个开源的有智能合约功能的公共区块链平台，通过其专用加密货币以太币（Ether，简称“ETH”）提供去中心化的以太虚拟机（Ethereum Virtual Machine）来处理点对点合约。由程序员维塔利克·布特林（Vitalik Buterin）受比特币启发后提出名为“下一代加密货币与去中心化应用平台”的设想。
- 全节点：全节点是拥有完整区块链帐本资料的节点，具备独立验证的能力来确认交易之有效性。全节点储存了所有区块的区块头Block Header与区块体Body（交易列表）。一个节点只要下载了完整且最新的区块链资料，稳定运行验证交易和同步区块信息，那它就是一个全节点了。由于每一个全节点都保有全网资料，所以即使其中部分节点出现问题，例如断网或被攻击，都不会影响整个区块链网络的安全性。一般而言矿工都需要运行全节点。
- 轻节点：即是轻量级的节点，具体定义是不储存或维护完整的区块链副本，只储存最小量的状态来作为发送或传递交易讯息的节点。轻节点只区块头Block Header，从而大幅降低储存空间的需求。
- 账户地址： 加密货币用于在网络上发送或接收交易的地址，类似于银行账号。
- 记账权：记录账本的权限，在区块链中矿工需要通过共识算法争夺记账权以获取奖励。
- 挖矿：在网络中，通过进行计算竞争获得记账权，进而获得区块的代币奖励以及交易费的奖励，而这种方式就是在系统中获取初始比特币的方法，被形象地比喻为挖矿。
- 手续费（transaction fee），矿工不仅可以获得出块奖励，同时也可以获得打包的交易发起者的手续费。这种方式主要为了防止发起无意义的交易，造成网络拥塞。同时也可以更好地激励矿工。
- 软硬分叉：由于区块链是一个由数据块组成的链式结构。所以，需要升级时实际上会从某一个数据块开始，连到两个不同的数据块上，从而分成了两条链；在软分叉升级中，因为新规则变得更严格了，新节点（升级后的节点）会拒绝某些交易的记账，而旧节点（未升级的节点）仍认可这些交易。如果新节点占多数，那么产生的区块数据就是按照新规则的；此时，旧节点所生成的区块，由于算力小，区块高度小，而且是短链而最终被放弃。可见，尽管在过渡期间有可能存在临时性的分叉，当多数节点都切换成新版本软件后，软分叉一般不会产生永久性分叉的链。在硬分叉中，按照新规则产生的区块只被新节点认可，旧节点则不认为新区块合法，因此，旧节点一直用旧规则来组织自己的链，所以，无论新旧节点数目的比例如何，一定会产生两条链。若大多数节点都升级到新版本，旧链能否成活要看有多少算力的支持。
- 跨链：由于区块链的孤立性和封闭性，以及链与链之间的高度异构化，区块链之间的数据流通、价值转移已成为阻碍区块链技术广泛落地应用的技术瓶颈。跨链技术即解决不同链间资产与数据等跨链操作问题，实现区块链互联互通、提升区块链互操作性与可扩展性的重要技术手段。
- DAPP：去中心化应用（Dapp，Decentralized Application）一般指运行在分布式网络上，参与者的信息被安全保护（也可能是匿名的），通过网络节点进行去中心化操作的应用。
- DAO：去中心化匿名组织（DAO，Decentralized Autonomous Organization）是一种基于区块链核心思想理念（由达成同一个共识的群体自发产生的共创、共建、共治、共享的协同行为）衍生出来的一种组织形态，将组织的管理和运营规则以智能合约的形式编码在区块链上，从而在没有集中控制或第三方干预的情况下自主运行的组织形式。



#### 发展历程

> *区块链1.0：以比特币为代表，它既是独立的区块链网络，又是单一的协议和应用，及三者于一身，其本质上就是一个保存基本记录交易的分布式账本，承载的是加密货币应用。*
>
> *区块链2.0： 以以太坊为代表，区块链网络上除了分布式帐本以外，增加了可以执行智能合约的程序代码，承载的应用场景从加密货币延伸到了加密资产。*
>
> *区块链3.0：自2017年起，业界涌现了大量区块链3.0项目，目的是以链上与链下结合的设计构建基础设施、平台、工具及去中心化应用，推动区块链技术普及应用余各行各业，为广大用户所接受并使用。*

- 区块链1.0

**比特币的诞生是区块链1.0时代到来的标志**。在这个时期,区块链技术的发展与数字货币密切相关,应用普遍集中在货币转移、兑换和支付等方面。从某种意义上讲,这个时期的区块链技术找到了一个解决货币和支付去中心化的方案。

百度百科上对比特币的定义是一种P2P形式的数字货币,点对点的传输意味着去中心化的支付系统。当中本聪提出“比特币”的概念并公开发行后,它便成为大家研究区块链的源头。在区块链1.0时代,主要创新是创建了一套去中心化的、公开透明的交易记录总账——其数据库由所有的网络节点共享,由“矿工”更新,全民维护,没有个人可以控制这个总账。

- 区块链2.0

**以太坊和智能合约的兴起是区块链2.0时代的标志**。得益于开的程序环境及智能合约的应用，区块链在这个时期得到了快速发展。它的应用范已经超越货币,延伸至期货、债券、对冲基金、私募股权、股票、年金、众筹、期权等金融衍生品。此外,随着公证文件、知识产权文件、资产所有权文件等电子化的进程与区块链的结合,让有形或无形的资产在区块链上都找到了可能的运行环境。

在以以太坊为代表的区块链上人们可以**编写资产的代码，创建新的区块链资产**。简单地说，即可以发行自己的区块链代币,而使用什么样的发行机制、代币叫什么名字、发行多少数量、怎样发行都由自己决定。同时也可以通过编写智能合约的代码来创造区块链资产的功能,比如投票、对赌、条件合同等。

尽管目前基于区块链的智能合约还处于初始阶段，但是其潜力却显而易见。例如可以用来**记录名下资产、遗嘱、合同等**，人们名下的房产车等有形的资产以数据的形式进入区块链，并以合约的形式生成一份遗嘱。根据遗嘱设定的条件，若干年以后设定的遗嘱程序被触发，这些资产将按照遗嘱人的意愿自动转给继承人，而无须法院或律师等第三方的裁定。律师的业务或许也将发生很大的改变，由裁定合约改为在区块链上创建智能合的模板、人们将以智能合约为基础,开展各种各样点对点的商业活动。届时人们再也不用担心因人性的贪婪而造成的毁约、欺诈等行为，以代码与程序在区块链上存在的智能合约不会受到任何人的操控，将客观公正地执行既定的合约。

- 区块链3.0

区块链3.0时代也是区块链全面应用的时代，由此构建一个大规模协作社会。除金融、经济等方面,此时的区块链在社会生活中的应用更为广泛,特别是在政府、健康、科学、文化和艺术等领域。同时，与其他技术结合更加深入，影响更加深远，结合云计算、大数据、人工智能、物联网技术等。

![](.\images\区块链发展历程.png)



#### 技术特点

1. 去中心化

   去中心化是区块链最基本的特征，意味着区块链不再依赖于中央处理节点，实现了数据的分布式记录、存储和更新。**由于使用分布式存储和算力，不存在中心化的硬件或管理机构，全网节点的权利和义务均等，系统中的数据本质是由全网节点共同维护的**。由于每个区块链节点都必须遵循同一规则，而该规则基于密码算法而非信用，同时每次数据更新需要网络内其他用户的批准，所以不需要一套第三方中介结构或信任机构背书。在传统的中心化网络中，对一个中心节点实行攻击即可破坏整个系统，而在一个去中心化的区块链网络中，攻击单个节点无法控制或破坏整个网络，掌握网内超过51%的节点只是获得控制权的开始而已。

2. 透明性
   区块链系统的数据记录对全网节点是透明的，数据记录的更新操作对全网节点也是透明的，这是区块链系统值得信任的基础。**由于区块链系统使用开源的程序、开放的规则和高参与度，区块链数据记录和运行规则可以被全网节点审查、追溯，具有很高的透明度**。

3. 开放性
   区块链系统是开放的，除了数据直接相关各方的私有信息被加密外，**区块链的数据对所有人公开（具有特殊权限要求的区块链系统除外）。任何人或参与节点都可以通过公开的接口查询区块链数据记录或者开发相关应用**，因此整个系统信息高度透明。

4. 自治性
   区块链采用基于协商一致的规范和协议，使整个系统中的所有节点能够在去信任的环境自由安全地交换数据、记录数据、更新数据，**把对个人或机构的信任改成对体系的信任，任何人为的干预都将不起作用**。

5. 信息不可篡改
   区块链系统的信息一旦经过验证并添加至区块链后，**由于网络中所有节点存储着同一份账本，数据会得到永久存储，无法更改**（具备特殊更改需求的私有区块链等系统除外）。除非能够同时控制系统中超过51%的节点，否则单个节点上对数据库的修改是无效的，因此区块链的数据稳定性和可靠性极高。

6. 匿名性
   区块链技术解决了节点间信任的问题，因此数据交换甚至交易均可在匿名的情况下进行。**由于节点之间的数据交换遵循固定且预知的算法，因而其数据交互是无须信任的，可以基于地址而非个人身份进行，因此交易双方无须通过公开身份的方式让对方产生信任**。

**FAQ**

> Q：匿名性与透明性是否冲突？
>
> A：不冲突，透明性主要是指交易数据历史记录的共享开放，即数据操作行为的可见、可追踪，侧重对操作行为合规性的共同监管;而隐私性特指对账户身份信息的保护。
>
> Q：区块链平台全流程不可篡改？
>
> A：区块链技术可以以相当高昂的作假代价保证在链上的数据不被篡改，但是无法保证在链外数据的真实性。
>
> 以阳澄湖大闸蟹区块链溯源造假为例，首先将外地蟹运往阳澄湖。打捞螃蟹期间记录过程，拍摄视频，然后贴上二维码，RFID，NFC标签，再装上有防伪的箱子，同时物流公司的集装箱配电子锁，电子锁有记录GPS轨迹的功能，配有加速度传感器。一切就绪后，准备防伪证书，视频，产品信息，将这些数据上链。发货，记录供应链数据，物流数据，GPS行车轨迹，中转站。最后商品上架。所有数据收集完毕，更新区块链，追加供应链数据。但这些流程都无法避免链外的数据从开始便是虚假的数据，无法保证物品信息的真实性。



#### 类型划分

- 公有链

公共区块链（Public Blockchain）：又称非许可区块链（Permissionless Blockchains）。**是指全世界任何人都可读取、可发送交易进行有效性确认，任何人都能参与其共识过程的区块链**（共识过程是维持区块链这种分布式数据库一致性、准确性的关键技术）。区块链上的数据记录公开，所有人都可以访问，都可以发出交易请求，并通过验证被写入区块链。共识过程的参与者通过密码学技术共同维护公共区块链数据的安全、透明、不可篡改。**公共区块链的典型应用包括比特币、以太坊等**。

公共区块链是完全分布式的区块链，区块链数据公开，用户参与程度高，同时易于产生网络效应，便于应用推广。然而，系统的运行需要依赖于内建的激励机制。

- 联盟链

联盟区块链（Consortium Blockchains）：又称许可区块链（Permissioned Blockchains），共同体区块链。**是指参与区块链的节点是事先选择好的，节点间通常有良好的网络连接等合作关系，区块链上的数据可以是公开的也可以是内部的，为部分意义上的分布式，可视为“部分去中心化”。**比如有若干家金融机构之间建立了某个共同体区块链，每个机构都运行着一个节点，而且为了使每个区块生效需要获得至少其中10个机构的确认。区块链可以允许每个机构可读取，或者只受限于共识验证参与者，或走混合型路线，例如区块的根哈希及应用程序接口对外公开，允许外界用来进行区块链数据和区块链状态信息查询等。**其典型应用包括超级账本（Hyperledger）、FISCO BCOS等**。

共同体区块链的参与节点间的连接状态较好、验证效率较高，只需较低的成本即可维持运行，提供高速交易处理的同时降低交易费用，有很好的扩展性，数据可以保持一定的隐私性。但是这也意味着在共识达成的前提下，参与节点可以一起篡改数据。 

- 私有链

私有区块链（Private Blockchain）：**参与的节点只有有限的范围，比如特定机构的自身用户等，数据的访问及使用有严格的权限管理。完全私有的区块链中写入权限仅在参与者手里，读取权限可以对外开放，也可以进行任意程度的限制**。相关的应用囊括数据库管理、数据库审计甚至公司管理，尽管在有些情况下希望私有区块链可以具有公共的可审计性，但在更多的情况下，没有公共的可读性。**由于是私有用户说了算，里面的数据没有无法篡改的特性**，对于第三方的保障力度大大降低。因此，目前很多私有区块链会通过依附在比特币等已有区块链的方式存在，定期将系统快照数据记录到比特币等系统中。

**私有区块链可以带来规则的改变。如果需要的话，运行着私有区块链的机构可以很容易地修改区块链的规则、回滚交易**。这一点似乎略有违背区块链的本质，但是却适用于一些特殊场景需求。

![](.\images\区块链类型.png)



#### 账本类型

- 基于交易的账本，transaction-based ledger —— 比特币采用的模式，每个货币都可以代表一串交易，不能显式地查看当前持有的货币数额，有着更好的隐私性和安全性，但是并不直观和便捷。由于没有账户数额，每个币需要附上币的来源。

- 基于账户的账本，account-based ledger —— 以太坊采用的模式，与日常生活银行账户类似，可以显式查看账户数额，更加直观和便捷，但是牺牲了一定的安全性和隐私性。

- 比特币采用的即是基于交易的模式（transaction-based ledger），比特币系统的全节点需要维护UTXO（Unspent Transaction Output，未支付交易输出），主要用于防范双重支付攻击，为了检测新的一笔交易是否合法，只有存在于UTXO集合中的币才能花销。UTXO集合中的每一个元素需要给出产生这个输出的交易哈希值以及在这笔交易中作为第几个输出。

  > 举例说明，A转给C共9 BTC，B转给D共2BTC，然后C再转给D共3BTC，此时UTXO则保存着A->C的6 BTC未花费输出、B->D的2 BTC未花费输出输出、C->D的3 BTC未花费输出。当计算D的余额时，则将所有指向D的未花费输出相加，即将B->D的2 BTC输出、C->D的3 BTC输出相加，余额为5 BTC。
  >
  > A->C(9 BTC)
  >
  > B->D(2 BTC)
  >
  > C->D(3 BTC)



1. 比特币UTXO
   - 比特币在基于UTXO的结构中存储有关用户约的数据，当前各个用户的余额是跟与其相关的每次交易各个输出累加起来的，**比较反直觉**。系统的整个状态就是一组UTXO的集合，每个UTXO都有一个所有者和一个面值，而交易会花费若干个用于输入的UTXO并根据规则创建若干个新的UTXO。
   - **每个引用的输入必须有效且尚未花费**，对于一个交易，必须包含有与每个输入的所有者匹配的签名，总输入必须大于等于总输出值。
   - **系统中用户的余额balance是用户具有私钥的UTXO的总值**。
2. 比特币UTXO模式优点
   - **更高程度的隐私**：如果用户为他们收到的每笔交易使用新地址，那么通常很难将账户相互链接起来，这很大程度上适用于货币，但不太适用于任意dapps，因为dapps通常涉及跟踪和用户绑定的复杂状态，可能不存在像货币那样简单的的用户状态划分方案
   - **潜在的可扩展性**：UTXO在理论上更符合可扩展性要求，因为只需要依赖拥有UTXO的人去维护基于Merkle树的所有权证明就够了，即是包括所有者在内的每个人都决定忘记某数据，那么也只有所有者受到对应UTXO的损失，不影响接下来的交易。但是在账户模式中，如果每个人都丢失了与账户相对应的Merkle树的部分，那将会使得和该账户有关的消息完全无法处理，包括发送币给他
3. 以太坊账户
   - 以太坊中设计了系统中所有账户的列表，每个账户包括了一个余额，和以太坊特殊定义的数据（代码和内部存储），**这种设计更符合直觉，与银行账户类似**。
   - **如果发送账户有足够的余额来支付则交易有效；在这种情况下发送账户先扣款，而收款账户将计入这笔收入**。
   - 如果接收账户有编写相关代码，则代码会自动运行，并且它的内部存储也可能被更改，或者代码还可能向其他账户发送额外的消息，这就会导致进一步的借贷资金关系。
4. 以太坊账户模式的优点
   - **可以节省大量空间**：不将UTXO分开存储，而是合为一个账户，每个交易只需要一个输入、一个签名并产生一个输出。
   - **更好的可替代性**：货币本质是同质化可替代的，UTXO的设计使得货币从来源分成了可花费和不可花费两类，这在实际应用中没有对应的模型
   - **更加简单**：更容易编码和理解，特别是设计复杂脚本的时候，UTXO在脚本逻辑复杂时更令人费解
   - **便于维护持久轻节点**：只要沿着特定方向扫描状态树，轻节点可以很容易地随时访问账户相关的数据，而UTXO每个交易都会使得状态引用发生改变，这对轻节点而言长时间运行dapp会有很大压力。



#### 总体架构

![](.\images\区块链架构.png)



#### 区块结构

区块链的结构如下图所示。一条区块链上有多个区块，每个区块包括区块头与区块体。区块头中主要包括版本号、前一区块哈希值（父区块）、[时间戳](https://so.csdn.net/so/search?q=时间戳&spm=1001.2101.3001.7020)、随机数、目标哈希、默克尔根；区块体中是通过默克尔树记录的账本信息。其中，区块头具体字段如下：

版本——4字节 版本号，跟踪使用软件/协议。

父区块哈希值——32字节，上一个区块哈希值。

Merkle根——32字节，该区块中交易的Merkle树根的哈希值。

时间戳——4字节，该区块产生时间。

难度目标——4字节 ，该区块工作量证明的难度目标，可以随网络整体算力变化而动态变化，保证出块速度维持在十分钟。

Nonce——4字节，工作量证明的随机调节的随机数，用以矿工调节符合工作量证明条件，同时使得哈希结果更加均匀分布。

其中，难度Difficulty每隔2100万个区块需要调整一次难度，使其出块速度维持在十分钟左右。随机数Nonce是挖矿是尝试的随机数，最终显示的随机数是找到的符合难度要求的随机数。

![](.\images\区块链结构.png)



#### 更多字段

比特币区块更多字段如下（来源：blockchain.com）

![](.\images\区块信息.png)

Hash：用来识别特定区块的唯一标识

Distance：此区块被构建出来到目前为止的时间

BTC：区块所有交易发送的加密货币累计金额

Value：区块被构建出来时所有交易的价值

Value Today：所有交易的当前价值

Input Value：所有交易输入金额的总和

Output Value：所有交易输出金额的总和

Transactions：此区块中包含的交易数量

Inputs：输入的总数量

Outputs：输出的总数量

Fees：奖励给矿工计算此区块哈希的交易费

Version：版本号

Merkle Root：默克尔树根节点

Difficulty：计算出此区块的难度值

Nonce：可以随机调节以满足PoW的随机值

Mined on：挖掘构建此区块的时间

Height：高度，连接到此区块链的数量



#### 智能合约

**智能合约是一套以数字形式定义的承诺，承诺控制着数字资产并包含了合约参与者约定的权利和义务，由计算机系统自动执行**。

承诺定义了智能合约的本质和目的。以一个销售合约为例：卖家承诺发送货物，买家承诺支付合理的货款。数字形式意味着合约需要被写入计算机可执行的代码中，只要参与者达成协定，智能合约建立的权利和义务，就由一台计算机或者计算机网络执行。

> If Event_X_Happened：
>
> ​	Send（爱丽 丝，1000$）
>
> Else：
>
> ​	Send（鲍伯，1000$）
>
> 意思是：如果事件X发生，则合约给爱丽丝发送1000美元；否则，给鲍伯发送1000美元。

智能合约组成部分：

①合约参与者：执行智能合约的相关参与者。

②合约资源集合：智能合约执行涉及的参与者资源，比如参与各方账户、拥有的数字财产等。

③自动状态机：智能合约下一步执行的关键，包括当前资源状态判断、下一步合约事务执行选择等。

④合约事务集合：智能合约的下一步动作或行为集合，控制着合约资产并对接收到的外界信息进行回应。

**关于智能合约的工作理论迟迟没有实现，一个重要原因是因为缺乏能够支持可编程合约的数字系统和技术。区块链技术的出现解决了该问题，不仅可以支持可编程合约，而且具有去中心化、不可篡改、过程透明可追踪等优点，天然适合于智能合约**。因此，也可以说，智能合约是区块链技术的特性之一。

如果说区块链1.0是以比特币为代表，解决了货币和支付手段的去中心化问题，那么区块链2.0就是更宏观地对整个市场去中心化，利用区块链技术转换许多不同的数字资产而不仅仅是比特币，通过转换创建不同资产的价值。区块链技术的去中心化账本功能可以被用来创建、确认、转移各种不同类型的资产及合约。几乎所有类型的金融交易都可以被改造成在区块链上使用，包括股票、私募股权、众筹、债券和其他类型的金融衍生品如期货、期权等。

**智能合约看上去就是一段计算机执行程序，满足可准确自动执行即可，那么为什么用传统的技术很难实现，而需要区块链技术等新技术呢？传统技术即使通过软件限制、性能优化等方法，也无法同时实现区块链的特性：一是数据无法删除、修改，只能新增，保证了历史的可追溯，同时作恶的成本将很高，因为其作恶行为将被永远记录；二是去中心化，避免了中心化因素的影响**。

基于区块链技术的智能合约不仅可以发挥智能合约在成本效率方面的优势，而且可以避免恶意行为对合约正常执行的干扰。将智能合约以数字化的形式写入区块链中，由区块链技术的特性保障存储、读取、执行整个过程透明可跟踪、不可篡改。同时，由区块链自带的共识算法构建出一套状态机系统，使智能合约能够高效地运行。



#### 共识算法

拜占庭将军问题

> 拜占庭帝国想要进攻一个强大的敌人，为此派出了10支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御5支常规拜占庭军队的同时袭击。基于一些原因，这10支军队不能集合在一起单点突破，必须在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少6支军队同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们能否找到一种分布式的协议来让他们能够远程协商，从而赢取战斗.

Lamport已经证明了在消息可能丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。拜占庭将军问题中并不去考虑通信兵是否会被截获或无法传达信息等问题，即消息传递的信道绝无问题。

拜占庭将军问题的实质就是要寻找一个方法，使得将军们能在一个有叛徒的非信任环境中建立对战斗计划的共识。在分布式系统中，特别是在区块链网络环境中，也和拜占庭将军的环境类似，有运行正常的服务器（类似忠诚的拜占庭将军），有故障的服务器，还有破坏者的服务器（类似叛变的拜占庭将军）。共识算法的核心是在正常的节点间形成对网络状态的共识。

求解拜占庭将军问题，隐含要满足以下两个条件：

- 每个忠诚的将军必须收到相同的命令值vi（vi是第i个将军的命令）。
- 如果第i个将军是忠诚的，那么他发送的命令和每个忠诚将军收到的vi相同。

于是，拜占庭将军问题的可以描述为：一个发送命令的将军要发送一个命令给其余n-1题个将军，使得：

IC1.所有忠诚的接收命令的将军遵守相同的命令；

IC2.如果发送命令的将军是忠诚的，那么所有忠诚的接收命令的将军遵守所接收的命令。

Lamport对拜占庭将军问题的研究表明[2]，当n>3m时，即叛徒的个数m小于将军总数n的1/3时，通过口头同步通信（假设通信是可靠的），可以构造同时满足IC1和IC2的解决方案，即将军们可以达成一致的命令。但如果通信是可认证、防篡改伪造的（如采用PKI认证，消息签名等），则在任意多的叛徒（至少得有两个忠诚将军）的情况下都可以找到解决方案。
而在异步通信情况下，情况就没有这么乐观。Fischer-Lynch-Paterson定理证明了，只要，有一个叛徒存在，拜占庭将军问题就无解。翻译成分布式计算语言，在一个多进程异步系统中，只要有一个进程不可靠，那么就不存在一个协议，此协议能保证有限时间内使所有进程达成一致。

由此可见，拜占庭将军问题在一个分布式系统中，是一个非常有挑战性的问题。因为分布式系统不能依靠同步通信，否则性能和效率将非常低。因此寻找一种实用的解决拜占庭将军问题的算法一直是分布式计算领域中的一个重要问题。

注：实用拜占庭容错协议（PBFT）和Raft是联盟链和私有链上常用的共识算法。而公共链的共识机制一般采用工作量证明（PoW）和权益证明（PoS）算法。



##### PBFT
实用拜占庭容错系统（Practical Byzantine Fault Tolerance，PBFT）由原始的拜占庭容错系统（BFT）改进而来，BFT由于需要展示其理论上的可行性而缺乏实用性。另外，还需要额外的时钟同步机制支持，算法的复杂度也是随节点增加而指数级增加。PBFT降低了拜占庭协议的运行复杂度，从指数级别降低到多项式级别（Polynomial），使拜占庭协议在分布式系统中应用成为可能。

PBFT是一类状态机拜占庭系统，要求共同维护一个状态，所有节点采取的行动一致。为此，**需要运行三类基本协议，包括一致性协议、检查点协议和视图更换协议**。我们主要关注支持系统日常运行的一致性协议。

一致性协议要求来自客户端的请求在每个服务节点上都按照一个确定的顺序执行。**这个协议把服务器节点分为两类：主节点和从节点，其中主节点仅一个。在协议中，主节点负责将客户端的请求排序；从节点按照主节点提供的顺序执行请求**。每个服务器节点在同样的配置信息下工作，该配置信息被称为视图，主节点更换，视图也随之变化。

**一致性协议至少包含若干个阶段：请求（request）、序号分配（pre-prepare）和响应（reply）**。根据协议设计的不同，可能包含相互交互（prepare），序号确认（commit）等阶段。

PBFT的一致性协议如图所示。PBFT系统通常假设故障节点数为m个，而整个服务节点数为3m+1个。每一个客户端的请求需要经过5个阶段，通过采用两次两两交互的方式在服务器达成一致之后再执行客户端的请求。由于客户端不能从服务器端获得任何服务器运行状态的信息，PBFT中主节点是否发生错误只能由服务器监测。如果服务器在一段时间内都不能完成客户端的请求，则会触发视图更换协议。

![](.\images\PBFT协议通信模式.png)

为了描述方便，PBFT系统通常假设故障节点数为m个，而所有服务节点数为3m+1个。图中显示了一个简化的PBFT的协议通信模式，其中C为客户端，N0~N3表示服务节点，特别的，N0为主节点，N3为故障节点，故障节点数为1，所有服务节点数为4，满足共识基本条件。整个协议的基本过程如下。

> 1）客户端发送请求，激活主节点的服务操作。
> 2）当主节点接收请求后，启动三阶段的协议以向各从节点广播请求。
> [2.1]序号分配阶段，主节点给请求赋值一个序列号n，广播序号分配消息和客户端的请求消息m，并将构造PRE-PREPARE消息给各从节点；这一步是为了防止主节点给不同从节点发送不同的请求。
> [2.2]交互阶段，从节点接收PRE-PREPARE消息，向其他服务节点广播PREPARE消息；**若收到超过一定数量**（2F，实际使用中，F为可以容忍的拜占庭节点个数）的相同请求，则进入Commit阶段；
> [2.3]序号确认阶段，在Prepare阶段时**若收到超过一定数量**（2F，实际使用中，F为可以容忍的拜占庭节点个数）的相同请求，则进入序号确认阶段，广播序号确认请求；各节点对视图内的请求和次序进行验证后，广播序号确认消息，执行收到的客户端的请求并给客户端以响应。
>
> 3）客户端等待来自不同节点的响应，若有故障节点数+1个响应相同，则该响应即为运算的结果。

我们假设N=4，F=1，即有四个节点，其中有一个节点是的，我们还使用上面的图，即节点3为故障节点。

> 1、客户端C发送请求到0节点，假设这里请求内容为“1”；
> 2、节点0收到C的请求后进行广播，将请求内容“1”扩散至节点123；
> 3、节点1、2、3收到后内容“1”后，再次广播，节点1->023，节点2->013，节点3作为故障节点不进行广播；
> 4、节点0，1，2会在上一阶段分别收到三个请求内容“1”，均超过了2个，于是节点0、1、2会分别广播请求内容“1”；
> 5、此时如果一个节点（0，1，2中任意一个）收到3即（2+1）条commit消息，即对C进行反馈。

PBFT在很多场景都有应用，在区块链场景中，一般适合于对强一致性有要求的私有链和联盟链场景。例如，在IBM主导的区块链超级账本项目中，PBFT是一个可选的共识协议。

除了PBFT之外，超级账本项目还引入了基于PBFT的自用共识协议，它的目的是希望在PBFT基础之上能够对节点的输出也做好共识，这是因为，超级账本项目的一个重要功能是提供区块链之上的智能合约，即在区块链上执行的一段代码，因此它会导致区块链账本上最终状态的不确定，为此这个自有共识协议会在PBFT实现的基础之上，引入代码执行结果签名进行验证。



##### Paxos

Paxos算法解决的问题正是分布式一致性问题，即一个分布式系统中的各个进程如何就某个值（决议）达成一致。

Paxos算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用大多数 (Majority) 机制保证了2F+1的容错能力，即2F+1个节点的系统最多允许F个节点同时出现故障。

一个或多个提议进程 (Proposer) 可以发起提案 (Proposal)，Paxos算法使所有提案中的某一个提案，在所有进程中达成一致。系统中的多数派同时认可该提案，即达成了一致。最多只针对一个确定的提案达成一致。

Paxos将系统中的角色分为提议者 (Proposer)，决策者 (Acceptor)，和最终决策学习者 (Learner):

- **Proposer**: 提出提案 (Proposal)。Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value)。
- **Acceptor**：参与决策，回应Proposers的提案。收到Proposal后可以接受提案，若Proposal获得多数Acceptors的接受，则称该Proposal被批准。
- **Learner**：不参与决策，从Proposers/Acceptors学习最新达成一致的提案（Value）。

在多副本状态机中，每个副本同时具有Proposer、Acceptor、Learner三种角色。

![](.\images\Paxos角色.png)

Paxos算法通过一个决议分为两个阶段（Learn阶段之前决议已经形成）：

1. 第一阶段：Prepare阶段。Proposer向Acceptors发出Prepare请求，Acceptors针对收到的Prepare请求进行Promise承诺。
2. 第二阶段：Accept阶段。Proposer收到多数Acceptors承诺的Promise后，向Acceptors发出Propose请求，Acceptors针对收到的Propose请求进行Accept处理。
3. 第三阶段：Learn阶段。Proposer在收到多数Acceptors的Accept之后，标志着本次Accept成功，决议形成，将形成的决议发送给所有Learners。

![](.\images\Paxos算法流程.png)

Paxos算法流程中的每条消息描述如下：

- **Prepare**: Proposer生成全局唯一且递增的Proposal ID (可使用时间戳加Server ID)，向所有Acceptors发送Prepare请求，这里无需携带提案内容，只携带Proposal ID即可。
- **Promise**: Acceptors收到Prepare请求后，做出“两个承诺，一个应答”。

两个承诺：

1. 不再接受Proposal ID小于等于（注意：这里是<= ）当前请求的Prepare请求。

2. 不再接受Proposal ID小于（注意：这里是< ）当前请求的Propose请求。

一个应答：

   不违背以前作出的承诺下，回复已经Accept过的提案中Proposal ID最大的那个提案的Value和Proposal ID，没有则返回空值。

- **Propose**: Proposer 收到多数Acceptors的Promise应答后，从应答中选择Proposal  ID最大的提案的Value，作为本次要发起的提案。如果所有应答的提案Value均为空值，则可以自己随意决定提案Value。然后携带当前Proposal ID，向所有Acceptors发送Propose请求。
- **Accept**: Acceptor收到Propose请求后，在不违背自己之前作出的承诺下，接受并持久化当前Proposal ID和提案Value。
- **Learn**: Proposer收到多数Acceptors的Accept后，决议形成，将形成的决议发送给所有Learners。

![](.\images\Paxos伪代码.png)

1. 获取一个Proposal ID n，为了保证Proposal ID唯一，可采用时间戳+Server ID生成；
2. Proposer向所有Acceptors广播Prepare(n)请求；
3. Acceptor比较n和minProposal，如果n>minProposal，minProposal=n，并且将 acceptedProposal 和 acceptedValue 返回；
4. Proposer接收到过半数回复后，如果发现有acceptedValue返回，将所有回复中acceptedProposal最大的acceptedValue作为本次提案的value，否则可以任意决定本次提案的value；
5. 到这里可以进入第二阶段，广播Accept (n,value) 到所有节点；
6. Acceptor比较n和minProposal，如果n>=minProposal，则acceptedProposal=minProposal=n，acceptedValue=value，本地持久化后，返回；否则，返回minProposal。
7. 提议者接收到过半数请求后，如果发现有返回值result >n，表示有更新的提议，跳转到1；否则value达成一致。

内容来源：https://zhuanlan.zhihu.com/p/31780743



##### Raft

在很多分布式系统场景下，并不需要解决拜占庭将军问题，也就是说，在这些分布式系统的实用场景下，其假设条件不需要考虑拜占庭故障，而只是处理一般的死机故障。在这种情况下，采用Paxos等协议会更加高效。Paxos是Lamport设计的保持分布式系统一致性的协议。但由于Paxos非常复杂，比较难以理解，因此后来出现了各种不同的实现和变种。Raft也是为了避免Paxos的复杂性而专门设计成易于理解的分布式一致性算法。在私有链和联盟链的场景下，通常共识算法有强一致性要求，同时对共识效率要求高。另外一般安全性要比公有链场景高，一般来说不会经常存在拜占庭故障。因此，在一些场景下，可以考虑采用非拜占庭协议的分布式共识算法。

在Hyperledger的Fabric项目中，共识模块被设计成可插拔的模块，支持像PBFT、Raft等共识算法。

Raft最初是一个用于管理复制日志的共识算法，它是一个为真实世界应用建立的协议，主要注重协议的落地性和可理解性。Raft是在非拜占庭故障下达成共识的强一致协议。

在区块链系统中，使用Raft实现记账共识的过程可以描述如下：首先选举一个leader，接着赋予leader完全的权力管理记账。leader从客户端接收记账请求，完成记账操作，生成区块，并复制到其他记账节点。有了leader简化了记账操作的管理。例如，leader能够决定是否接受新的交易记录项而无需考虑其他的记账节点，leader可能失效或与其他节点失去联系，这时，系统就会选出新的leader。

给定leader方法，Raft将共识问题分解为三个相对独立的子问题。

- leader选举：现有的leader失效时，必须选出新leader。

- 记账：leader必须接受来自客户端的交易记录项，在参与共识记账的节点中进行复制，并使其他的记账节点认可交易所对应的区块。

- 安全：若某个记账节点对其状态机应用了某个特定的区块项，其他的服务器不能对同一个区块索引应用不同的命令。

1. Raft基础
    一个Raft集群通常包含5个服务器，允许系统有两个故障服务器。**每个服务器处于3个状态之一：leader、follower或candidate。正常操作状态下，仅有一个leader，其他的服务器均为follower**。follower是被动的，不会对自身发出请求而是对来自leader和candidate的请求做出响应。leader处理所有的客户端请求（若客户端联系follower，则该follower将转发给leader）。candidate状态用来选举leader。
    Raft阶段主要分为两个，**首先是leader选举过程，然后在选举出来的leader基础上进行正常操作，比如日志复制、记账等**。
2. leader选举
    当follower在选举超时时间内未收到leader的心跳消息，则转换为candidate状态，反之则一直保持follower状态。为了避免选举冲突，这个超时时间是一个150~300ms之间的随机数。 一般而言，在Raft系统中：
    1）任何一个服务器都可以成为一个候选者candidate，并向其他服务器follower发出要求选举自己的请求。
    2）其他服务器同意了，发出OK。注意，如果在这个过程中，有一个follower宕机，没有收到请求选举的要求，此时候选者可以自己选自己，只要达到N/2+1的大多数票，候选人还是可以成为leader的。

  	   3）这样这个候选者就成为了leader领导人，它可以向选民也就是follower发出指令，比如进行记账。
  	     4）以后通过心跳进行记账的通知。
  	     5）一旦这个leader崩溃了，那么follower中有一个成为候选者，并发出邀票选举。
  	     6）follower同意后，其成为leader，继续承担记账等指导工作。

3. 记账过程
   Raft的记账过程按以下步骤完成：
   1）假设leader领导人已经选出，这时客户端发出增加一个日志的要求：
   2）leader要求follower遵从他的指令，都将这个新的日志内容追加到他们各自日志中：
   3）大多数follower服务器将交易记录写入账本后，确认追加成功，发出确认成功信息；
   4）在下一个心跳中，leader会通知所有follower更新确认的项目。
   对于每个新的交易记录，重复上述过程。
   
   如果在这一过程中，发生了网络通信故障，使得leader不能访问大多数follower了，那么leader只能正常更新它能访问的那些follower服务器。而大多数的服务器follower因为没有了leader，他们将重新选举一个候选者作为leader，然后这个leader作为代表与外界打交道，如果外界要求其添加新的交易记录，这个新的leader就按上述步骤通知大多数follower，如果这时网络故障修复了，那么原先的leader就变成follower，在失联阶段，这个老leader的任何更新都不能算确认，都回滚，接收新的leader的新的更新。

内容来源：https://zhuanlan.zhihu.com/p/146204513



##### PoW

PoW，Proof of Working中文译为工作量证明。从去中心化账本系统的角度看，每个加入这个系统的节点都要保存一份完整的账本，但每个节点却不能同时记账，因为节点处于不同的环境，接收到不同的信息，如果同时记账的话，必然会导致账本的不一致，造成混乱。因此，需要有共识来达成哪个节点有权记账。比特币区块链通过竞争记账的方式解决去中心化的记账系统的一致性问题。

比特币系统设计了以每个节点的计算能力即“算力”来竞争记账权的机制。在比特币系统中，大约每10分钟进行一轮算力竞赛，竞赛的胜利者，就获得一次记账的权力，并向其他节点同步新增账本信息。

然而，在一个去中心化的系统中，谁有权判定竞争的结果呢？比特币系统是通过一个称为“工作量证明”的机制完成的。

简单地说，PoW就是一份确认工作端做过一定量工作的证明。PoW系统的主要特征是计算的不对称性。工作端需要做一定难度的工作得出一个结果，验证方却很容易通过结果来检查工作端是不是做了相应的工作。

举个例子，给定字符串“blockchain”，我们给出的工作量要求是，可以在这个字符串后面连接一个称为nonce的整数值串，对连接后的字符串进行SHA256哈希运算，如果得到的哈希结果（以十六进制的形式表示）是以若干个0开头的，则验证通过。为了达到这个工作量证明的目标，我们需要不停地递增nonce值，对得到的新字符串进行SHA256哈希运算。按照这个规则，需要经过2688次计算才能找到前3位均为0的哈希值，而要找到前6位均为0的哈希值，则需进行620969次计算。

![](.\images\PoW示例.png)

对于特定字符串后接随机nonce值所构成的串，要找到这样的nonce值，满足前n位均为0的SHA256值，需要多次进行哈希值的计算。一般来说，n值越大，需要完成的哈希计算量也越大。由于哈希值的伪随机特性，要寻找4个前导0的哈希值，预期大概要进行216 次尝试， 这个数学期望的计算次数，就是所要求的“工作量”。



##### PoS

PoW机制有一些缺点，比如挖矿时会浪费大量的资源、整个网络处理效率较低等等。为了解决这些问题，PoS（ Proof of Stake, POS）股份证明共识机制就应运而生，PoS在共识层面上借鉴很多PoW的设计，如区块设计，矿工选择，分叉处理，交易验证等。

POS主要是通过权益记账的方式，来解决网络的效率低下、资源浪费和各节点的一致性问题，简单来说，就是谁拥有的权益多谁说了算。PoS规定：虽然每个人都可以自由地加入进来成为节点，但只有满足一定条件的节点，比如抵押一定数量的代币，才有资格成为验证节点，也就是候选人。

成为候选人后，系统会通过算法，选择一部分人作为出块节点，每隔一段时间，会重新选择，选取过程中，算法会保证选取的结果不能被操纵，也不能被预测，从而避免网络被某一节点所控制。只有成为出块节点，也就是矿工，才能参与数据的处理、争夺记账的权利。PoW是人人都可以成为矿工，而PoS则是通过一系列筛选，才能成为矿工。

整个流程简单总结起来就是：**持币人将代币抵押，获得出块的机会，然后PoS共识中会通过选举算法，按照持币量比例，从中选出出块矿工。矿工在指定高度完成打包交易，生成新区块，并广播区块，广播的区块经过验证人验证交易，通过验证后，区块得到确认**。这样一轮PoS的共识过程就完成了。

PoS机制的优势在于，它解决了PoW中的资源浪费、效率低下等问题。但它同样也有一些缺点。比如，PoS机制中初始的代币分发比较模糊，如果初始代币分发不下去，就很难形成之后的股权证明。但最大的问题还是容易造成强者恒强的局面，代币越多则越容易获得更多的代币，理论上掌握51%的代币就能掌控整个网络，所以其去中心化程度较弱。



##### DPoS

POS机制虽然考虑到了POW的不足，但依据权益结余来选择，会导致首富账户的权力过大，可能支配记账权。股份授权证明（Delegated Proof of Stake, DPOS）的出现正是基于解决POW机制和POS机制的这类不足。 

DPOS与POS原理相同，**主要区别在于节点选举若干代理人，由代理人验证和记账**。其合规监管、性能、资源消耗和容错性与PoS相似。原理是让每一个持有比特股的人进行投票，由此产生101位代表 ,  我们可以将其理解为101个超级节点或者矿池，而这101个超级节点彼此的权利是完全相等的，这些节点作为代理进行验证和记账。从某种角度来看，DPOS类似于董事会投票。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。



#### 应用场景

- 区块链与金融服务：支付领域、资产数字化、智能证券、清算与结算、客户验证识别
- 区块链与供应链管理：物流、溯源防伪、
- 区块链与文化娱乐：作品版权、文化众筹
- 区块链与智能制造：工业物联网、智能生产制造
- 区块链与社会公益
- 区块链与教育：教育存证、产学合作

<img src=".\images\区块链应用场景概览.png" style="zoom: 67%;" />



#### 发展方向

**扩容技术**：当前主流的区块链网络，如比特币和以太坊，仍然存在着吞吐量不足的问题，这限制了它们的实际应用场景。因此，扩容技术是当前区块链技术的重要方向之一，以提高区块链网络的吞吐量和性能。

**隐私保护技术**：区块链网络中的交易记录都是公开的，这使得用户的个人隐私有可能被泄露。为了保护用户的隐私，需要开发出更加高效、安全、匿名的隐私保护技术，以防止交易信息的泄露。

**智能合约技术**：智能合约是区块链技术的重要应用之一，它可以实现自动化、去中心化的合约执行，这对于许多应用场景具有重要意义。未来的发展方向是将智能合约技术更好地与实际业务结合，构建更加完善的智能合约应用系统。

**跨链技术**：区块链网络之间的互联互通是未来的重要发展方向，这需要开发出更加高效、安全、可靠的跨链技术，以实现不同区块链网络之间的数据交换和价值转移。

**共识机制**：共识机制是区块链技术的基础技术之一，是区块链网络的对等方就网络中数据的当前状态达成一致的过程，通过共识算法在区块链网络中建立可靠性和信任。 目前相当一部分期刊或会议论文针对共识机制提出改进与创新。

**联邦学习**：联邦学习是在保障大数据交换时的信息安全、保护终端数据和个人数据隐私、保证合法合规的前提下，在多参与方或多计算节点之间开展高效率的机器学习的一种新兴人工智能基础技术，在保障数据安全和交换、训练效率前提下进行有效的机器学习。区块链作为一个去中心化、数据加密、不可篡改的分布式共享数据库，可以为联邦学习的数据交换提供数据保密性来对用户隐私进行保障，保证各参与方之间的数据安全，也可以保证多参与方提供数据进行模型训练的数据一致性，区块链的价值驱动激励机制也能够增加各参与方之间提供数据、更新网络模型参数的积极性。



#### 存在问题

- 双重支付问题

双重支付问题是指同一个货币可以使用多次，这是所有数字化货币需要解决的问题，因为数字化货币区别于纸质货币，支付则转移。数字货币本质是电脑中信息，可以进行任意复制。中心化的方案是中心化机构对每份货币进行编号，同时维护一张货币持有者表，实时更新持有人信息。去中心化的方案则是区块链。比特币采用基于交易的模式（transaction-based ledger），比特币系统的全节点需要维护UTXO（Unspent Transaction Output，未支付交易输出），主要用于防范双重支付攻击，为了检测新的一笔交易是否合法，只有存在于UTXO集合中的币才能花销。



- 矿池算力集中问题

早期的矿工由一些技术爱好者组成，他们提供机器用于分布式记账。到了后期，挖矿已经发展成为一种职业，组成了专门从事挖矿的团队。由于挖矿得到的货币数量和机器的运算能力大小成正比，因此从概率上看，采用越快速的硬件，在所有矿工中算力的占比越高，就能够获得越多的货币。矿工们为了获得更高的收益，彼此之间在算力上进行较量，算力低的矿工会因挖不到币而逐渐被淘汰出局。从参与的硬件上看，最开始矿工们采用通用的CPU（中央处理器）来挖矿。后来大家发现GPU（图形处理器）能够提高并行计算能力和吞吐量，效率更高，于是纷纷采用GPU挖矿。再后来，出现了专门为挖矿设计的集成电路（Application Specific Integrated Circuit，ASIC）芯片，目前已经成为挖矿行业主流的硬件设备。

随着全网算力的不断增加，单打独斗的小矿工已经没有规模优势，挖到加密货币的时间非常不确定，运气不好的话可能要几年才能挖到一个有效区块，有点像买彩票中奖一样。为了使收入更加平稳，矿工们可以组成矿池（Mining Pool），由矿池管理者统一分派挖矿的计算任务，挖到的币都归矿池管理者所有。矿池管理者根据各个矿工贡献的算力比例，定期分配挖矿的收入。矿池已经成为加密货币区块链网络算力的主要来源，零散的矿工由于经济上不占优势，基本上已退出了挖矿的行列。

矿池能够给矿工带来相对稳定的收入，但是也带来了新的问题。矿池把原来分散的算力集中起来统一管理，这违背了区块链的去中心化原则，在矿池规模不断增加的过程中，有的矿池在全网的算力达到了相当大的比例，甚至排前几位的矿池的算力总和可以超过全网的51%。从理论上说，如果能够控制整个网络达到或超过51%以上的算力，就可以控制区块链的记账权。这样比特币等加密货币依赖的分布式记账方式将被破坏，同一个货币可以多次使用（即重复花费，也叫双花，double spend），这样，信用体系将不复存在，加密货币体系将被彻底摧毁。

51%算力的攻击问题一直是加密货币体系中的“达摩克利斯之剑”，包括矿池在内的所有参与者都会非常小心地避免出现这种情况。一方面，对矿池来说，增大规模对自己有利，可以挖到更多的币，而且在一些特殊事件上有较多的话语权，例如在社区讨论加密货币软件重大变更的时候，由于最终的软件采用决定权在矿工，因此，矿池的规模越大，表决权就越大。另一方面，如果少数几个矿池的算力总和超过或接近51%，整个系统就不再是去中心化的系统，将会引发用户对加密货币的信任危机。所以，规模太大的矿池，通常会自觉地停止接收新成员，以避免与系统玉石俱焚。加盟矿池的矿工，也会尽量选择分散算力的矿池，避免一家独大的情形出现。



- 51%攻击

矿池算力集中产生51%攻击问题，准确来说，应当是50%+问题，从原理上看，只要能控制全网50%以上算力，攻击者将可以修改账本和阻止他人挖矿，从而威胁到整个系统安全。那么拥有50%以上的算力是怎样劫持区块链的数据的呢？一种方法是通过分叉（forking）的方式。如图所示，正常的矿工在区块链上挖矿，攻击者把自己的货币花掉（购买服务商品等），这笔花费会记录在区块链的数据中，假定交易记录在区块4中。攻击者这时暗中伪造另一条区块链的数据，将自己地址上的货币重新转账到其他地址，记录在自己伪造的区块4a中。由于在算力上的优势，攻击者比网络中其余的矿工计算得更快，从而得到一条更长的区块链数据，如图中区块4a到区块7a为攻击者的链，比其余矿工的链（区块4到区块6）更长。在公共区块链中，最长的链始终代表正确的分支，攻击者只要把自己的较长的区块数据发布到网上，其余矿工就会认同攻击者的数据，从而接受区块4a到区块7a的数据，而原来区块4中的交易被推翻和抹去，这样就达到了同一货币双重花费的目的。

![](.\笔记所用资料\图片\算力优势篡改数据.png)

比特币等采用公有区块链技术的加密货币，所有发生的交易在理论上都没有“最终性”（Finality），只要有足够的算力，都是可以被推翻的。在实际中，推翻之前的区块数据需要的算力和时间都相当惊人，所需成本可能远远大于收益，还不如按规矩挖矿，因此，即使存在理论上的可能性，也极少有人发动算力攻击。51%攻击方法不能偷走别人地址里面的货币，却可以实现攻击者的货币多重使用，从而摧毁加密货币的信任体系，使得币价大跌，攻击者或许可以通过做空货币的方式获利。鉴于51%攻击的破坏性强，加密货币的参与者
（如开发者、用户、矿工等）都会密切监视可能存在的攻击，并随时进行防备。



#### 会议与期刊

1. Conference

> ### A
>
> - [USENIX Security (Usenix Security Symposium)](https://github.com/PlyTools/awesome-blockchain-papers#usenix-security-a) <= 2022 Winter
> - [S&P (IEEE Security and Privacy)](https://github.com/PlyTools/awesome-blockchain-papers#sp-a) <= 2023 First Cycle
> - [CCS (ACM Conference on Computer and Communications Security)](https://github.com/PlyTools/awesome-blockchain-papers#ccs-a) <= 2022
> - [NDSS (Network and Distributed System Security)](https://github.com/PlyTools/awesome-blockchain-papers#ndss-a) <= 2023
> - [CRYPTO (International Cryptology Conference)](https://github.com/PlyTools/awesome-blockchain-papers#crypto-a) <= 2020 (waiting for notifications, 2021.4.19)
> - [EUROCRYPT (European Cryptology Conference)](https://github.com/PlyTools/awesome-blockchain-papers#eurocrypt-a) <= 2021
> - [INFOCOM (IEEE International Conference on Computer Communications)](https://github.com/PlyTools/awesome-blockchain-papers#-a) <= 2022
> - [SOSP (ACM Symposium on Operating Systems Principles)](https://github.com/PlyTools/awesome-blockchain-papers#sosp-a) <= 2021
> - [NSDI (USENIX Symposium on Networked Systems Design and Implementation)](https://github.com/PlyTools/awesome-blockchain-papers#nsdi-a) <= 2020
> - [VLDB (International Conference on Very Large Data Bases)](https://github.com/PlyTools/awesome-blockchain-papers#vldb-a) <= 2020
> - [OSDI (USENIX Symposium on Operating Systems Design and Implementations)](https://github.com/PlyTools/awesome-blockchain-papers#osdi-a) <= 2021
> - [SIGMOD (ACM Conference on Management of Data)](https://github.com/PlyTools/awesome-blockchain-papers#sigmod-a) <= 2020
> - [ASE (International Conference on Automated Software Engineering)](https://github.com/PlyTools/awesome-blockchain-papers#ase-a) <= 2020
> - [ICSE (International Conference on Software Engineering)](https://github.com/PlyTools/awesome-blockchain-papers#icse-a)<=2021
>
> 
>
> ### B
>
> - [ASIACRYPT (International Conference on the Theory and Application of Cryptology and Information Security)](https://github.com/PlyTools/awesome-blockchain-papers#asiacrypt-b) <= 2020 (Calling for paper in 2021)
> - [ESORICS (European Symposium on Research in Computer Security)](https://github.com/PlyTools/awesome-blockchain-papers#esorics-b) <= 2020
> - [ACSAC (Annual Computer Security Applications Conference)](https://github.com/PlyTools/awesome-blockchain-papers#acsac-b) <= 2020
> - [EuroSys (European Conference on Computer Systems)](https://github.com/PlyTools/awesome-blockchain-papers#eurosys-b) <= 2020
> - [ICDCS (IEEE International Conference on Distributed Computing Systems)](https://github.com/PlyTools/awesome-blockchain-papers#icdcs-b) <= 2020
> - [PODC (ACM Symposium on Principles of Distributed Computing)](https://github.com/PlyTools/awesome-blockchain-papers#podc-b) <= 2020
> - [CoNEXT (ACM Conference on Emerging Networking EXperiments and Technologies)](https://github.com/PlyTools/awesome-blockchain-papers#conext-b) <= 2020



2. Journal

> - [TOCS (ACM Transactions on Computer Systems)](https://github.com/PlyTools/awesome-blockchain-papers#tocs-a) <= 2022
> - [TOPLAS (ACM Transactions on Programming Languages & Systems)](https://github.com/PlyTools/awesome-blockchain-papers#toplas-a) <= 2022
> - [JACM (Journal of the ACM)](https://github.com/PlyTools/awesome-blockchain-papers#jacm-a) <= 2023 issue 1
> - [Journal of Cryptology](https://github.com/PlyTools/awesome-blockchain-papers#journal-of-cryptology-a) <= 2023 issue 1
> - [TDSC (IEEE Transactions on Dependable and Secure Computing)](https://github.com/PlyTools/awesome-blockchain-papers#tdsc-a) <= 2023 issue 1
> - [TIFS (IEEE Transactions on Information Forensics and Security)](https://github.com/PlyTools/awesome-blockchain-papers#tifs-a) <=2021

内容来源：https://github.com/PlyTools/awesome-blockchain-papers



### 区块链进阶

#### 支付通道

#### 闪电网络

#### 侧链

#### 跨链

#### 简化支付验证

#### 同态加密

#### 环签名

#### 多方安全计算